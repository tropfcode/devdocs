

.. _sphx_glr_gallery_lines_bars_and_markers_fill_between_demo.py:


==============================
Filling the area between lines
==============================

This example shows how to use ``fill_between`` to color between lines based on
user-defined logic.



.. code-block:: python


    import matplotlib.pyplot as plt
    import numpy as np

    x = np.arange(0.0, 2, 0.01)
    y1 = np.sin(2 * np.pi * x)
    y2 = 1.2 * np.sin(4 * np.pi * x)








.. code-block:: python


    fig, (ax1, ax2, ax3) = plt.subplots(3, 1, sharex=True)

    ax1.fill_between(x, 0, y1)
    ax1.set_ylabel('between y1 and 0')

    ax2.fill_between(x, y1, 1)
    ax2.set_ylabel('between y1 and 1')

    ax3.fill_between(x, y1, y2)
    ax3.set_ylabel('between y1 and y2')
    ax3.set_xlabel('x')




.. image:: /gallery/lines_bars_and_markers/images/sphx_glr_fill_between_demo_001.png
    :align: center




Now fill between y1 and y2 where a logical condition is met.  Note
this is different than calling
``fill_between(x[where], y1[where], y2[where] ...)``
because of edge effects over multiple contiguous regions.



.. code-block:: python


    fig, (ax, ax1) = plt.subplots(2, 1, sharex=True)
    ax.plot(x, y1, x, y2, color='black')
    ax.fill_between(x, y1, y2, where=y2 >= y1, facecolor='green', interpolate=True)
    ax.fill_between(x, y1, y2, where=y2 <= y1, facecolor='red', interpolate=True)
    ax.set_title('fill between where')

    # Test support for masked arrays.
    y2 = np.ma.masked_greater(y2, 1.0)
    ax1.plot(x, y1, x, y2, color='black')
    ax1.fill_between(x, y1, y2, where=y2 >= y1,
                     facecolor='green', interpolate=True)
    ax1.fill_between(x, y1, y2, where=y2 <= y1,
                     facecolor='red', interpolate=True)
    ax1.set_title('Now regions with y2>1 are masked')




.. image:: /gallery/lines_bars_and_markers/images/sphx_glr_fill_between_demo_002.png
    :align: center




This example illustrates a problem; because of the data
gridding, there are undesired unfilled triangles at the crossover
points.  A brute-force solution would be to interpolate all
arrays to a very fine grid before plotting.


Use transforms to create axes spans where a certain condition is satisfied:



.. code-block:: python


    fig, ax = plt.subplots()
    y = np.sin(4 * np.pi * x)
    ax.plot(x, y, color='black')

    # use data coordinates for the x-axis and the axes coordinates for the y-axis
    import matplotlib.transforms as mtransforms
    trans = mtransforms.blended_transform_factory(ax.transData, ax.transAxes)
    theta = 0.9
    ax.axhline(theta, color='green', lw=2, alpha=0.5)
    ax.axhline(-theta, color='red', lw=2, alpha=0.5)
    ax.fill_between(x, 0, 1, where=y > theta,
                    facecolor='green', alpha=0.5, transform=trans)
    ax.fill_between(x, 0, 1, where=y < -theta,
                    facecolor='red', alpha=0.5, transform=trans)


    plt.show()



.. image:: /gallery/lines_bars_and_markers/images/sphx_glr_fill_between_demo_003.png
    :align: center




**Total running time of the script:** ( 0 minutes  0.203 seconds)



.. container:: sphx-glr-footer


  .. container:: sphx-glr-download

     :download:`Download Python source code: fill_between_demo.py <fill_between_demo.py>`



  .. container:: sphx-glr-download

     :download:`Download Jupyter notebook: fill_between_demo.ipynb <fill_between_demo.ipynb>`

.. rst-class:: sphx-glr-signature

    `Generated by Sphinx-Gallery <https://sphinx-gallery.readthedocs.io>`_
